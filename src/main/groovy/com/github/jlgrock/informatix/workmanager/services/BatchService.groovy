package com.github.jlgrock.informatix.workmanager.services
import com.github.jlgrock.informatix.workmanager.domain.assignment.Assignment
import com.github.jlgrock.informatix.workmanager.domain.assignment.AssignmentRepository
import com.github.jlgrock.informatix.workmanager.domain.assignment.AssignmentStatus
import com.github.jlgrock.informatix.workmanager.domain.attachment.Attachment
import com.github.jlgrock.informatix.workmanager.domain.batch.Batch
import com.github.jlgrock.informatix.workmanager.domain.batch.BatchDTO
import com.github.jlgrock.informatix.workmanager.domain.batch.BatchRepository
import com.github.jlgrock.informatix.workmanager.domain.batch.BatchStatus
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.MediaType
import org.springframework.stereotype.Service

import java.time.LocalDateTime
/**
 *
 */
@Service
class BatchService {
    private static Logger LOGGER = LoggerFactory.getLogger(BatchService.class)

    @Autowired
    BatchRepository batchRepository

    @Autowired
    AssignmentRepository assignmentsRepository

    List<BatchDTO> findAllBatches(String searchTerm) {
        List<Batch> batches
        if (searchTerm == null) {
            batches = batchRepository.findAllByOrderByIdDesc()
        } else {
            batches = batchRepository.findAllByNameContainingIgnoreCaseOrderByIdDesc(searchTerm)
        }
        LOGGER.debug("batch size: ${batches?.size()}")
        batches.collect { batch ->
            List<Assignment> assignments = assignmentsRepository.findAllByBatchOrderByIdAsc(batch)
            new BatchDTO(batch, assignments)
        }
    }

    BatchDTO add(String filename, String contentType, byte[] data) {
        ProcessedData processedData = processData(data)

        // save original attachment
        Attachment original = new Attachment([
                fileName: filename,
                uploadDate: LocalDateTime.now(),
                numberOfBytes: data.size(),
                mediaType: MediaType.parseMediaType(contentType),
                data: data]);

        Map<String, Attachment> postValidation = validateFile(original)

        Batch batch = new Batch(
                numberOfRecords: processedData.numberOfRecords,
                numberOfUnvalidatedRecords: processedData.numberOfUnvalidatedRecords,
                original: original,
                postValidation: postValidation.successFile,
                status: BatchStatus.UNASSIGNED
        )
        batchRepository.save(batch)

        Assignment failedAssignment = new Assignment(
                batch: batch,
                isAutoGenerated: true,
                numberOfRecords: 76, //TODO fix this
                original: postValidation.failedFile,
                status: AssignmentStatus.COMPLETED
        )
        assignmentsRepository.save(failedAssignment)

        new BatchDTO(batch, failedAssignment)
    }

    private Map<String, Attachment> validateFile(Attachment attachment) {
        // TODO read the original batch file and find out which rows failed

        // TODO create a new document out of the non-failed rows

        // TODO store the non-failed rows document in an attachment

        // currently just copying the attachment over
        Attachment successFile = new Attachment(
            fileName: stripExtension(attachment.fileName) + "_processed.xlsx",
            uploadDate: LocalDateTime.now(),
            numberOfBytes: attachment.data.size(),
            mediaType: attachment.mediaType,
            data: attachment.data
        )

        // TODO create a new document out of the failed rows
        Attachment failedFile = new Attachment(
                fileName: stripExtension(attachment.fileName) + "_processed.xlsx",
                uploadDate: LocalDateTime.now(),
                numberOfBytes: attachment.data.size(),
                mediaType: attachment.mediaType,
                data: attachment.data
        )

        //return it
        [ successFile: successFile, failedFile: failedFile] as Map<String, Attachment>
    }

    private ProcessedData processData(byte[] data) {
        // TODO this needs to read the xlsx and store it to the database with information saved
        ProcessedData p = new ProcessedData()
        p.numberOfRecords = 5
        p.postValidatedFile = data
        p
    }

    private static stripExtension(String filename) {
        def names = filename.split("\\.")
        names.size() > 1 ? (names - names[-1]).join('.') : names[0]
    }

    class ProcessedData {
        int numberOfRecords
        int numberOfUnvalidatedRecords
        byte[] postValidatedFile
    }

    private BatchStatus determineBatchStatus(Batch batch) {
        Collection<Assignment> assignments = assignmentsRepository.findAllByBatchOrderByIdAsc(batch)
        boolean unfinished = false
        int size = 0
        assignments.each {
            if (!it.isAutoGenerated) {
                size++
                if (it.completed == null
                        || it.completed.size() == 0
                        || it.billableHours == null
                        || it.status != AssignmentStatus.COMPLETED) {
                    unfinished = true
                }
            }

        }
        if (size == 0) {
            return BatchStatus.UNASSIGNED
        }
        if (unfinished) {
            return BatchStatus.UNCOMPLETED
        }
        if (batch.reviewed != null && batch.reviewed.size() != 0) {
            return BatchStatus.REVIEWED
        }
        BatchStatus.COMPLETED
    }

    void updateBatchStatus(int batchId) {
        Batch batch = batchRepository.findOne(batchId)
        batch.status = determineBatchStatus(batch)
        batchRepository.save(batch)
    }

    void createCompiled(int batchId) {
        Batch batch = batchRepository.findOne(batchId)

        //TODO adjust this to properly create a compiled attachment
        byte[] bytes = new byte[24];
        batch.compiled = new Attachment(
                fileName: "bla.xlsx",
                uploadDate: LocalDateTime.now(),
                numberOfBytes: 24,
                mediaType: MediaType.parseMediaType("application/xlsx"),
                data: bytes
        )
        batchRepository.save(batch)
    }

    void deleteCompiled(int batchId) {
        Batch batch = batchRepository.findOne(batchId)
        batch.compiled = null
        batchRepository.save(batch)
    }
}
